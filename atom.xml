<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Ankur Goel]]></title>
  <link href="http://AnkurGel.github.io/atom.xml" rel="self"/>
  <link href="http://AnkurGel.github.io/"/>
  <updated>2013-09-01T17:41:19+05:30</updated>
  <id>http://AnkurGel.github.io/</id>
  <author>
    <name><![CDATA[Ankur Goel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Utility functions and Documentation]]></title>
    <link href="http://AnkurGel.github.io/blog/2013/09/01/utility-functions-and-documentation/"/>
    <updated>2013-09-01T17:15:00+05:30</updated>
    <id>http://AnkurGel.github.io/blog/2013/09/01/utility-functions-and-documentation</id>
    <content type="html"><![CDATA[<p>I have been coding the utility functions for matrices and vectors which we are/will need frequently in further functionalities.  <br/>
One of it is to <code>add_constant</code> to a matrix. <code>add_constant</code> prepends or appends a column of ones to a matrix if it already doesn&#8217;t have one.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#=Adds a column of constants.</span>
</span><span class='line'><span class="c1">#Appends a column of ones to the matrix/array if first argument is false</span>
</span><span class='line'><span class="c1">#If an n-array, first checks if one column of ones is already present</span>
</span><span class='line'><span class="c1">#if present, then original(self) is returned, else, prepends with a vector of ones</span>
</span><span class='line'><span class="k">def</span> <span class="nf">add_constant</span><span class="p">(</span><span class="n">prepend</span> <span class="o">=</span> <span class="kp">true</span><span class="p">)</span>
</span><span class='line'>  <span class="c1">#for Matrix</span>
</span><span class='line'>  <span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">column_size</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_f</span><span class="p">)</span> <span class="o">==</span> <span class="ss">Object</span><span class="p">:</span><span class="ss">:Vector</span><span class="o">.</span><span class="n">elements</span><span class="p">(</span><span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">row_size</span><span class="p">,</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="p">))</span>
</span><span class='line'>      <span class="k">return</span> <span class="nb">self</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="c1">#append/prepend a column of one&#39;s</span>
</span><span class='line'>  <span class="n">vectors</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">row_size</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">r</span><span class="o">|</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">prepend</span>
</span><span class='line'>      <span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">].</span><span class="n">concat</span><span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="nb">self</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="k">return</span> <span class="no">Matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>There are other such methods such as <code>chain_dot</code> which carries out dot multplication of matrices in chain. It uses the ruby&#8217;s <code>reduce</code> ability to reduce the available arguments(matrices) to consequential product.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#=Chain Product</span>
</span><span class='line'><span class="c1">#Class method</span>
</span><span class='line'><span class="c1">#Returns the chain product of two matrices</span>
</span><span class='line'><span class="c1">#==Usage:</span>
</span><span class='line'><span class="c1">#Let `a` be 4 * 3 matrix, </span>
</span><span class='line'><span class="c1">#Let `b` be 3 * 3 matrix, </span>
</span><span class='line'><span class="c1">#Let `c` be 3 * 1 matrix,</span>
</span><span class='line'><span class="c1">#then `Matrix.chain_dot(a, b, c)`</span>
</span><span class='line'><span class="c1">#===*NOTE*: Send the matrices in multiplicative order with proper dimensions</span>
</span><span class='line'><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">chain_dot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'>  <span class="c1">#inspired by Statsmodels</span>
</span><span class='line'>  <span class="k">begin</span>
</span><span class='line'>    <span class="n">args</span><span class="o">.</span><span class="n">reduce</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="p">}</span> <span class="c1">#perform matrix multiplication in order</span>
</span><span class='line'>  <span class="k">rescue</span> <span class="ss">ExceptionForMatrix</span><span class="p">:</span><span class="ss">:ErrDimensionMismatch</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;ExceptionForMatrix: Please provide matrices with proper multiplicative dimensions&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Apart from adding such functionalities, I have covered entire <em>documentation</em> of <code>bio-statsample-timeseries</code>. I made sure to explain role of each function, every input parameter, and return type of the function. In most of the cases, I also added the usage examples too. <br/>
Later, I will add the usage examples in all those which are still not equipped with that and details about parameters wherever it is still missing.</p>

<p>After this, with the great help from Claudio and Ra&#8217;s <a href="https://github.com/AnkurGel/bioruby-statsample-timeseries/issues/2">pointers</a> about modular(namespace) hierarchial convention; we managed to make it more conventional. :) <br/>
Here are the final results:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Statsample::TimeSeries</span> <span class="c1">#Module for all Timeseries related stuff</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Statsample</span><span class="o">::</span><span class="ss">TimeSeries</span><span class="p">:</span><span class="ss">:Series</span> <span class="o">&lt;</span> <span class="ss">Statsmple</span><span class="p">:</span><span class="ss">:Vector</span>  <span class="c1"># Class containing a timeseries objects and general related methods</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">Statsample::TimeSeries::Pacf</span> <span class="c1">#Pacf related methods</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Statsample</span><span class="o">::</span><span class="ss">TimeSeries</span><span class="p">:</span><span class="ss">:Arima</span> <span class="c1">#Arima class, which is initialized by class method</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Statsample</span><span class="o">::</span><span class="ss">TimeSeries</span><span class="p">:</span><span class="ss">:Arima</span><span class="o">::</span><span class="no">KalmanFilter</span> <span class="c1"># For Kalman Filter on ARIMA</span>
</span></code></pre></td></tr></table></div></figure>


<p>We are now reading and continuing to code Kalman filter. Hope it doesn&#8217;t stay tricky. :)</p>

<p>Till next time, <br/>
Cheers, <br/>
- Ankur Goel</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kalman and Cholesky decomposition]]></title>
    <link href="http://AnkurGel.github.io/blog/2013/08/20/kalman-and-cholesky-decomposition/"/>
    <updated>2013-08-20T14:06:00+05:30</updated>
    <id>http://AnkurGel.github.io/blog/2013/08/20/kalman-and-cholesky-decomposition</id>
    <content type="html"><![CDATA[<p>Hi everyone!</p>

<p>First, this blog is coming a bit late than usual; sorry for that. I was traveling to my hometown(Delhi) for some occassion and couldn&#8217;t do much in last 3 days. I am thankful to Claudio for his support.</p>

<p>So, in this phase, as discussed, we continue to compose estimation methods for <code>ARMA/ARIMA</code>. Good news - Most of method seem to be in place. Even if we manage to make atleast one or two; we seem to be in good position. Bad news - the estimation methods, I am hanging out with has lot of pre-requisitie. These requisites are both theoretical and technical. So, I&#8217;m currently initially coding them as I go. This comes with a plus. These methods will be extremely valuable in many other analysis. ;)</p>

<h2>Kalman Fiter</h2>

<p>So, we started up with developing Kalman filter. Kalman filter is one of the crucial method for ARIMA model fit. It is primarily identified with constitution of 3 matrices -</p>

<ul>
<li><em>T Matrix</em> : It is the coefficient matrix for the state vector in the state equation.</li>
<li><em>R Matrix</em> : It is the coefficient matrix for the state vector in the observation equation.</li>
<li><em>Z Matrix</em>: It is the selctor matrix.</li>
</ul>


<p>Currently, these methods are available as <code>class methods</code> of the new class - <code>KalmanFilter</code> in <code>ARIMA</code>. It can be found <a href="https://github.com/AnkurGel/bioruby-statsample-timeseries/blob/master/lib/bio-statsample-timeseries/arima.rb#L142">here</a></p>

<p>The example snippet of T matrix code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">T</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="nb">p</span><span class="p">)</span>
</span><span class='line'>    <span class="n">arr</span> <span class="o">=</span> <span class="no">Matrix</span><span class="o">.</span><span class="n">zero</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</span><span class='line'>    <span class="n">params_padded</span> <span class="o">=</span> <span class="ss">Statsample</span><span class="p">:</span><span class="ss">:Vector</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="ss">:scale</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">params_padded</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">p</span><span class="o">]</span> <span class="o">=</span> <span class="n">params</span><span class="o">[</span><span class="n">k</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">(</span><span class="nb">p</span><span class="o">+</span><span class="n">k</span><span class="p">)</span><span class="o">]</span>
</span><span class='line'>    <span class="n">intermediate_matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="c1">#appending an array filled with padded values in beginning</span>
</span><span class='line'>    <span class="n">intermediate_matrix</span><span class="o">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="o">[</span><span class="n">params_padded</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">#now generating column matrix for that:</span>
</span><span class='line'>    <span class="n">arr</span> <span class="o">=</span> <span class="no">Matrix</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span><span class="n">intermediate_matrix</span><span class="p">)</span>
</span><span class='line'>    <span class="n">arr_00</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">#identify matrix substituition in matrix except row[0] and column[0]</span>
</span><span class='line'>    <span class="n">r</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
</span><span class='line'>      <span class="n">arr</span><span class="o">[</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr_00</span>
</span><span class='line'>    <span class="n">arr</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The complete coding of <code>R</code> matrix is still pending.</p>

<h2>Cholesky Decomposition:</h2>

<p>While venturing into another estimation method; I encoutered Cholesky decomposition of matrix; and it took me by surprise.
<a href="http://en.wikipedia.org/wiki/Cholesky_decomposition">Cholesky decomposition</a> is the decomposition of a symmetric matrix in the product of lower half of Hermitian matrix and it&#8217;s conjugate.</p>

<p>I implemented the following as extension of <code>Matrix</code> <a href="https://github.com/AnkurGel/bioruby-statsample-timeseries/blob/master/lib/bio-statsample-timeseries/utility.rb#L50">here</a>. Since the matrix has to be <strong>symmetric</strong> before it can be decomposed to Hermitian matrix, I also wrote down <a href="https://github.com/AnkurGel/bioruby-statsample-timeseries/blob/master/lib/bio-statsample-timeseries/utility.rb#L35"><code>is_symmetric?</code></a> method to check if the matrix is symmetric or not. Though <code>symmetric?</code> is present in Ruby Matrix 1.9+, to satisfy back compatibility with Ruby 1.8, it was necessary.</p>

<p>That&#8217;s pretty much for now.</p>

<p>Continuing the work.</p>

<p>Cheers, <br/>
- Ankur Goel</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bio-statsample-timeseries Deliverables]]></title>
    <link href="http://AnkurGel.github.io/blog/2013/08/06/bio-statsample-timeseries-deliverables/"/>
    <updated>2013-08-06T16:02:00+05:30</updated>
    <id>http://AnkurGel.github.io/blog/2013/08/06/bio-statsample-timeseries-deliverables</id>
    <content type="html"><![CDATA[<p>Hi there!</p>

<p>This summer, I&#8217;m working on new <a href="https://github.com/AnkurGel/bioruby-statsample-timeseries"><code>bio-statsample-timeseries</code></a> gem. This will act as an extension to existing <a href="http://rubygems.org/gems/statsample"><code>Statsample</code></a> by Claudio Bustos. I aim to add the support of <strong>timeseries</strong> and related functionalities to it.</p>

<p>I am using <code>MiniTest</code> for unit-testing and Cucumber for the feature testing. In the intial period of first phase, I targeted on completing as much portion of testing as possible for existing <code>Statsample</code>.</p>

<p>Also, another goal is to make statsample supported by current and previous Ruby versions. We are taking care of that - <a href="https://travis-ci.org/AnkurGel/bioruby-statsample-timeseries">travis-ci.org/AnkurGel/bioruby-statsample-timeseries</a> by managing support of Ruby 2.0.0, 1.9.3, 1.9.2, jruby-19mode and rbx-19mode.</p>

<p>Now, we have many basic and advanced functions in place for timeseries. We have enabled:</p>

<ul>
<li>Autocorrelation</li>
<li>Partial autocorrelation with:

<ul>
<li>yule-walker</li>
<li>levinson-durbin</li>
<li>biased levinson-durbin</li>
</ul>
</li>
<li>Autocovariance</li>
<li>Lag and mean of series</li>
<li>correlation (almost complete)</li>
</ul>


<p>Apart from them, we are also working on ARIMA module(another goal of project) and have realized the simulation of:</p>

<ul>
<li>AR (Autoregressive) model</li>
<li>MA (Moving Average) model</li>
<li>ARMA model</li>
</ul>


<p>For those simulations, the requisite was to pre-acquire the values of parameters against which the simulation was generated. For pure model, in this phase we aim to work and complete most of such functions to support that. We have completed:</p>

<ul>
<li>Yule-walker for AR modelling.</li>
<li>Levinson-Durbin for AR modelling</li>
</ul>


<p>I will now start with other such modelling like <code>burg</code> algorithm and <code>IRLS</code>. :). <br/>
The deliverables of project must be the all this stuff. Since the estimation methods for these modelling poses lot of theoretical and accuracy challenges, the pace to achieve them may not be too fast. :).</p>

<h2>Documentation</h2>

<p>One thing I liked in R and Statsmodels is amount of documentation and detail of API for developers and users. I wish to have similar amount of documentation for Statsample, so as to attract more number of Ruby developers and scientists. <br/>
Considering the amount of code present in Statsample and bio-statsample-timeseries combined, maybe devoting considerable quality time for RDoc documentation will be a good idea!.</p>

<h2>After</h2>

<p>I already expressed my wish to continue contributing to project after timeline to Claudio. We will continue to work on it! On next module, if this is near completion. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Levinson-Durbin and Autocovariance]]></title>
    <link href="http://AnkurGel.github.io/blog/2013/08/04/levinson-durbin-and-autocovariance/"/>
    <updated>2013-08-04T16:02:00+05:30</updated>
    <id>http://AnkurGel.github.io/blog/2013/08/04/levinson-durbin-and-autocovariance</id>
    <content type="html"><![CDATA[<p>As discussed, I am implementing estimation methods for <code>phi</code> in <code>AR</code> modelling. We covered <code>yule_walker</code> earlier, I&#8217;ll write a post about that. After it&#8217;s implementation, we go ahead with another estimation method - <strong>Levinson Durbin</strong></p>

<p><a href="http://en.wikipedia.org/wiki/Levinson_recursion">Levinson-Durbin</a> requires timeline series to be demeaned(<code>series = series - series.mean</code>) and it&#8217;s autocovavirance.</p>

<p>Autocovariance of series is represented by summation of summation of product of series with series at lag <code>k</code>. That is, summation of <code>(x_i * x_{i+lag})</code>. It is also directly related with <code>acf</code> of series as <code>acf(k) = acvf(h) / acvf(0)</code>. It&#8217;s code can now be found in <code>Statsample::TimeSeries</code>&#8217;s <code>acvf</code> method.</p>

<p>Now, with the help of autocovariance series, our <a href="https://github.com/AnkurGel/bioruby-statsample-timeseries/blob/master/lib/bio-statsample-timeseries/timeseries/pacf.rb#L16"><code>levinson_durbin</code></a> function recursively computes the following parameters:</p>

<ul>
<li>sigma_v : estimation of error variance</li>
<li>arcoefs : AR phi values for timeseries</li>
<li>pac     : unbiased levinson pacf estiation</li>
<li>sigma   : sigma for AR.</li>
</ul>


<p>L-D performs recursive matrix and vector multiplications to populate it&#8217;s toeplitz matrix. Here is some code depicting those manipulations:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>      <span class="n">order</span> <span class="o">=</span> <span class="n">nlags</span>
</span><span class='line'>      <span class="n">phi</span> <span class="o">=</span> <span class="no">Matrix</span><span class="o">.</span><span class="n">zero</span><span class="p">(</span><span class="n">nlags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>      <span class="n">sig</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">nlags</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">#setting initial point for recursion:</span>
</span><span class='line'>      <span class="n">phi</span><span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">series</span><span class="o">[</span><span class="mi">1</span><span class="o">]/</span><span class="n">series</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'>      <span class="c1">#phi[1][1] = series[1]/series[0]</span>
</span><span class='line'>      <span class="n">sig</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">series</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">phi</span><span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">series</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>      <span class="mi">2</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="o">|</span>
</span><span class='line'>        <span class="n">phi</span><span class="o">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">series</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">-</span> <span class="p">(</span><span class="ss">Statsample</span><span class="p">:</span><span class="ss">:Vector</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">phi</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span> <span class="o">*</span> <span class="n">series</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">k</span><span class="o">].</span><span class="n">reverse</span><span class="o">.</span><span class="n">to_ts</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span><span class="o">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'>        <span class="c1">#some serious refinement needed in above for matrix manipulation. Will do today</span>
</span><span class='line'>        <span class="mi">1</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">j</span><span class="o">|</span>
</span><span class='line'>          <span class="n">phi</span><span class="o">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">phi</span><span class="o">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">phi</span><span class="o">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">]</span> <span class="o">*</span> <span class="n">phi</span><span class="o">[</span><span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>        <span class="n">sig</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">sig</span><span class="o">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">phi</span><span class="o">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Implementation can be found <a href="https://github.com/AnkurGel/bioruby-statsample-timeseries/blob/master/lib/bio-statsample-timeseries/timeseries/pacf.rb#L16">here</a>.</p>

<p>Now, in this week, I will integrate this in AR modelling and perform some tests to verify the estimation. And will soon start with next estimation method :)</p>

<p>Cheers, <br/>
Ankur Goel</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AR/MA, ARMA acf - pacf visualizations]]></title>
    <link href="http://AnkurGel.github.io/blog/2013/07/20/ar-ma-arma-acf-pacf-visualizations/"/>
    <updated>2013-07-20T18:27:00+05:30</updated>
    <id>http://AnkurGel.github.io/blog/2013/07/20/ar-ma-arma-acf-pacf-visualizations</id>
    <content type="html"><![CDATA[<p>As mentioned in <a href="http://ankurgoel.com/blog/2013/07/18/ar-and-ma-simulations/">previous post</a>, I have been working with Autoregressive and Moving Average simulations. <br/>
To test the correctness of estimations by our simulations, we employ <em>acf</em>(Autocorrelation) and <em>pacf</em>(partial autocorrelation) to our use. For different order of AR and MA, we get the varying visualizations with them, such as:</p>

<ul>
<li>Exponential decreasing curves.</li>
<li>Damped sine waves.</li>
<li>Positive and negative spikes, etc.</li>
</ul>


<p>While analyzing and writing tests for same, I also took some time to visualize that data on ilne and bar charts to get a clearer picture:</p>

<h2>AR(1) process</h2>

<p>AR(1) process is the autoregressive simulation with order p = 1, i.e, with one value of phi.<br/>
Ideal AR(p) process is represented by: <br/>
<img src="http://upload.wikimedia.org/math/f/0/6/f06ba0e2d8668944406852d7f72ac2f1.png" alt="Courtesy: Wikipedia" /> <br/>
To simulate this, install <a href="http://github.com/AnkurGel/bioruby-statsample-timeseries"><code>bio-statsample-timeseries</code></a> from here.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;bio-statsample-timeseries&#39;</span>
</span><span class='line'><span class="kp">include</span> <span class="ss">Statsample</span><span class="p">:</span><span class="ss">:ARIMA</span>
</span><span class='line'><span class="n">series</span> <span class="o">=</span> <span class="no">ARIMA</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">ar_1</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">ar_sim</span><span class="p">(</span><span class="mi">1500</span><span class="p">,</span> <span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="mi">9</span><span class="o">]</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here, number of observations, <strong>n</strong> = 1500 (greater value is preferrable for best fit), p = 1, with <em>phi</em> = [0.9].</p>

<h3>ACF</h3>

<p>To generate it&#8217;s autocorrelation</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">acf</span> <span class="o">=</span> <span class="n">ar_1</span><span class="o">.</span><span class="n">to_ts</span><span class="o">.</span><span class="n">acf</span>
</span><span class='line'><span class="nb">p</span> <span class="n">acf</span>
</span></code></pre></td></tr></table></div></figure>


<p>For an AR(1) process, <code>acf</code> must exponentially decay if <code>phi &gt; 0</code>, or alternate in sign if <code>phi &lt; 0</code><a href="https://www.scss.tcd.ie/Rozenn.Dahyot/ST7005/11ACFPACF.pdf">Ref</a>. Go through the analysis above. It can be visualized as:  <br/>
When <code>phi &gt; 0</code>, acf decreases exponentially:  <br/>
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/AR%281%29_positive_phi_acf.png" alt="AR(1) positive phi acf" />
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/AR%281%29_positive_phi_acf_line.png" alt="AR(1) positive phi acf line chart" /> <br/>
When <code>phi &lt; 0</code>, you get the alternate acf lags:  <br/>
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/AR%281%29_negative_phi_acf.png" alt="AR(1) negative phi acf" />
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/AR%281%29_negative_phi_acf_line.png" alt="AR(1) negative phi acf line chart" /></p>

<h3>PACF</h3>

<p>To generate it&#8217;s partial autocorrelation:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">pacf</span> <span class="o">=</span> <span class="n">ar_1</span><span class="o">.</span><span class="n">to_ts</span><span class="o">.</span><span class="n">pacf</span>
</span><span class='line'><span class="nb">p</span> <span class="n">pacf</span>
</span></code></pre></td></tr></table></div></figure>


<p>For AR(1) process, <code>pacf</code> must have a spike at lag 1, then 0. Former spike must be positive if <code>phi &gt; 0</code>, otherwise, negative spike. Have a look at the pacf series generated above. On visualizing the data:  <br/>
When <code>phi &gt; 0</code>, positive lag at 1 and 0(contains 1.0):  <br/>
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/AR%281%29_postive_phi_pacf.png" alt="AR(1) positive phi pacf" />
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/AR%281%29_postive_phi_pacf_line.png" alt="AR(1) positive phi pacf line chart" /> <br/>
When <code>phi &lt; 0</code>, negative lag at 1:  <br/>
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/AR%281%29_negative_phi_pacf.png" alt="AR(1) negative phi pacf bar chart" /></p>

<p>Here is the representation of ideal acf-vs-pacf for positive phi in AR(1): <br/>
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/ar1_postive_acf_vs_pacf.png" alt="AR(1) acf/pacf" /></p>

<h2>AR(P) process</h2>

<p>Simulation of AR(p) process is similar as AR(1).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">series</span> <span class="o">=</span> <span class="no">ARIMA</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">phi_params</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="o">]</span>
</span><span class='line'><span class="n">ar_p</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">ar_sim</span><span class="p">(</span><span class="mi">1500</span><span class="p">,</span> <span class="n">phi_params</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="c1">#acf</span>
</span><span class='line'><span class="n">acf</span> <span class="o">=</span> <span class="n">ar_p</span><span class="o">.</span><span class="n">to_ts</span><span class="o">.</span><span class="n">acf</span>
</span><span class='line'><span class="n">pacf</span> <span class="o">=</span> <span class="n">ar_p</span><span class="o">.</span><span class="n">to_ts</span><span class="o">.</span><span class="n">pacf</span>
</span></code></pre></td></tr></table></div></figure>


<h3>ACF</h3>

<p>For AR(p), <code>acf</code> must give a damping sine wave. The pattern is greatly dependent on the value and sign of phi parameters. <br/>
When positive content in phi coefficients is more, you will get a sine wave starting from positive side, else, sine wave will start from negative side.  <br/>
Notice, the damping sine wave starting from positive side here:  <br/>
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/AR%28p%29_positive_phi_sine_wave.png" alt="AR(p) positive" /> <br/>
and negative side here.. <br/>
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/AR%28p%29_negative_phi_acf_sine_wave.png" alt="AR(p) negative" /></p>

<h3>PACF</h3>

<p><code>pacf</code> gives spike at lag 0(value = 1.0, default) and from lag 1 to lag k. The example above, features AR(2) process, for this, we must get spikes at lag 1 - 2 as: <br/>
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/AR%28p%29_positive_phi_pacf_spikes.png" alt="AR(p) pacf spikes" /></p>

<h2>MA(1) process</h2>

<p>MA(1) process is the moving average simulation with order <code>q = 1</code>, i.e, with one value of <code>theta</code>.<br/>
To simulate this, use <code>ma_sim</code> method from <code>Statsample::ARIMA::ARIMA</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;bio-statsample-timeseries&#39;</span>
</span><span class='line'><span class="kp">include</span> <span class="ss">Statsample</span><span class="p">:</span><span class="ss">:ARIMA</span>
</span><span class='line'><span class="n">series</span> <span class="o">=</span> <span class="no">ARIMA</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">ma_1</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">ma_sim</span><span class="p">(</span><span class="mi">1500</span><span class="p">,</span> <span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="mi">9</span><span class="o">]</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="n">acf</span> <span class="o">=</span> <span class="n">ma_1</span><span class="o">.</span><span class="n">to_ts</span><span class="o">.</span><span class="n">acf</span>
</span><span class='line'><span class="n">pacf</span> <span class="o">=</span> <span class="n">ma_1</span><span class="o">.</span><span class="n">to_ts</span><span class="o">.</span><span class="n">pacf</span>
</span></code></pre></td></tr></table></div></figure>


<p>For <code>theta &gt; 0</code>, for <code>MA(1)</code>, we must get a positive spike at lag 1 as: <br/>
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/MA%281%29_postive_acf.png" alt="MA(1) positive acf" />
For <code>theta &lt; 0</code>, the spike at lag 1 must be in negatie direction as: <br/>
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/MA%281%29_negative_acf.png" alt="MA(1) negative acf" /></p>

<p>When I put these two visualizations aside each other, the visualization seems quite fit: <br/>
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/MA%281%29_acf_positive_vs_negative.png" alt="MA(1) positive/negative" /></p>

<h2>MA(q) process</h2>

<p>MA(q) process. <code>Order = q</code> => Number of theta coefficients = q. <br/>
Ideal MA(q) process is represented by:  <br/>
<img src="https://upload.wikimedia.org/math/9/5/a/95a85ea60c0cd898823ffe17fb509475.png" alt="MA(q) Courtesy: Wiki" /></p>

<h3>ACF</h3>

<p>Similar to AR(1) simulation, it will have spikes for lag 1 - lag p as : <br/>
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/MA%28q%29_acf_spikes.png" alt="MA(1) acf" /></p>

<h3>PACF</h3>

<p>In pacf of MA(q) simulation, we observe exponentially decaying/damping sine wave. <br/>
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/MA%28q%29_paf_damped_sine_wave.png" alt="MA(q) pacf" /></p>

<h2>ARMA(p, q) process</h2>

<p>ARMA(p, q) is combination of autoregressive and moving average simulations. <br/>
When <code>q = 0</code>, the process is called as pure autoregressive process; when <code>p = 0</code>, the process is purely moving average. <br/>
The simulator of ARMA can be found as <code>arma_sim</code> in <code>Statsample::ARIMA::ARIMA</code>. <br/>
For <code>ARMA(1, 1)</code> process, here are the comparisons of the visualizations from <code>R</code> and this code, which just made my day :)</p>

<p><img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/ARMA/ARMA%281%2C1%29_R.png" alt="R ARMA(1, 1)" />
<img src="https://dl.dropboxusercontent.com/u/102071534/sciruby/ARMA/ARMA%281%2C1%29_sim.png" alt="Statsample ARMA(1,1)" /></p>

<p>Quite Fit!</p>

<p>Cheers, <br/>
- Ankur Goel</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AR and MA simulations]]></title>
    <link href="http://AnkurGel.github.io/blog/2013/07/18/ar-and-ma-simulations/"/>
    <updated>2013-07-18T18:56:00+05:30</updated>
    <id>http://AnkurGel.github.io/blog/2013/07/18/ar-and-ma-simulations</id>
    <content type="html"><![CDATA[<p>I have been reading and coding <strong>AR(Autoregressive Model)</strong> and <strong>Moving Average(MA)</strong> basics. <br/>
First, I am very grateful for all the patience by Claudio Bustos to help me with understanding this. There is still lot to be learnt in these models, but I will keep bugging him. :D</p>

<p>We wrote the simulations for <code>AR(p)</code> and <code>MA(q)</code>. The idea behind creating them is to first simulate the process with known coefficients and then move on to write ARMA process which could also estimate the coefficients.</p>

<h2>Autoregressive Model</h2>

<p>This model is represented by <strong>AR(p)</strong> where p is the order of this model. For a pure autoregressive model, we consider order of moving average model as 0.</p>

<p><code>AR(p)</code> is represented by the following equation:</p>

<p><img src="http://upload.wikimedia.org/math/f/0/6/f06ba0e2d8668944406852d7f72ac2f1.png" alt="Courtesy: Wikipedia" /></p>

<p>Here, <img src="http://upload.wikimedia.org/math/a/3/4/a34ff7b33cb6b9dee064215437f52349.png" alt="" /> are the parameters of model, and <img src="http://upload.wikimedia.org/math/1/5/8/158300cdcfab79e14b49519a9c907ab9.png" alt="" /> is the error noise. <br/>
To realize this model, we have to observe and keep track of previous <code>x(t)</code> values, and realize current value with observed summation and error noise.</p>

<h4>Here is that code fragment of general AR(p) simulator:</h4>

<ul>
<li>It creates a buffer initially to prevent &#8216;broken values&#8217;, and trims that buffer before returning the result.</li>
<li>It goes on to create the backshifts vector. The backshift vector depends on the ongoing iteration from <code>(1..n)</code>.</li>
<li>After creating backshifts vector, it extracts the required <code>phi</code> values from the stack.</li>
<li>Then it performs vector multiplication - <code>backshifts * parameters</code>, then adds the result.</li>
<li>The current <code>x(t)</code> values is then returned with active white noise.</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">ar_sim</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
</span><span class='line'>  <span class="n">err_nor</span> <span class="o">=</span> <span class="ss">Distribution</span><span class="p">:</span><span class="ss">:Normal</span><span class="o">.</span><span class="n">rng</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
</span><span class='line'>  <span class="c1">#creating buffer with 10 random values</span>
</span><span class='line'>  <span class="n">buffer</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">err_nor</span><span class="o">.</span><span class="n">call</span><span class="p">())</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">x</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">#For now &quot;phi&quot; are the known model parameters</span>
</span><span class='line'>  <span class="c1">#later we will obtain it by Yule-walker/Burg</span>
</span><span class='line'>
</span><span class='line'>  <span class="mi">11</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">11</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phi</span><span class="o">.</span><span class="n">size</span>
</span><span class='line'>      <span class="c1">#dependent on previous accumulation of x</span>
</span><span class='line'>      <span class="n">backshifts</span> <span class="o">=</span> <span class="n">create_vector</span><span class="p">(</span><span class="n">x</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">i</span><span class="o">].</span><span class="n">reverse</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="c1">#dependent on number of phi size/order</span>
</span><span class='line'>      <span class="n">backshifts</span> <span class="o">=</span> <span class="n">create_vector</span><span class="p">(</span><span class="n">x</span><span class="o">[</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">phi</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">i</span><span class="o">].</span><span class="n">reverse</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="n">parameters</span> <span class="o">=</span> <span class="n">create_vector</span><span class="p">(</span><span class="n">phi</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">backshifts</span><span class="o">.</span><span class="n">size</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">summation</span> <span class="o">=</span> <span class="p">(</span><span class="n">backshifts</span> <span class="o">*</span> <span class="n">parameters</span><span class="p">)</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="ss">:+</span><span class="p">)</span>
</span><span class='line'>    <span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">summation</span> <span class="o">+</span> <span class="n">err_nor</span><span class="o">.</span><span class="n">call</span><span class="p">()</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">x</span> <span class="o">-</span> <span class="n">buffer</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>    <br/>
There are certain tests which will now be performed in context of <code>acf</code> and <code>pacf</code>, which I earlier coded. They form the basis of correctness of our autoregressive estimation. :) Expect the next post about those tests.</p>

<h2>Moving Average Model</h2>

<p>This model is represented by <strong>MA(q)</strong>, where <code>q</code> is the order of this model. Again, for pure moving-average model, we consider <code>p=0</code>.</p>

<p>This is represented by following equation: <br/>
<img src="https://upload.wikimedia.org/math/9/5/a/95a85ea60c0cd898823ffe17fb509475.png" alt="" /></p>

<p>Unlike <em>autoregressive model</em>, this model was somewhat hard to obtain. It needs to obsere previous <em>error noise</em> instead of previous <code>x(t)</code> values. And the series largely depends upon the order of the model.</p>

<p>It&#8217;s code can also be found on my <a href="https://github.com/ankurgel/statsample/tree/arima">github</a> branch.</p>

<p>I am now currently working on those tests analysis, I mentioned; for various combinations of <code>AR(p)</code> and <code>MA(q)</code>. As they get over, I will move to realize few algorithms like <em>yule walker</em> and <em>burgs</em> for estimation of coefficients.</p>

<p>Cheers, <br/>
-Ankur Goel</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cuke up with Cucumber]]></title>
    <link href="http://AnkurGel.github.io/blog/2013/07/11/cuke-up-with-cucumber/"/>
    <updated>2013-07-11T22:25:00+05:30</updated>
    <id>http://AnkurGel.github.io/blog/2013/07/11/cuke-up-with-cucumber</id>
    <content type="html"><![CDATA[<p>Recently, I wrote few <a href="https://github.com/AnkurGel/statsample/tree/master/features">features</a> in <a href="http://cukes.info/">Cucumber</a>.
<strong>Cucumber</strong> is a powerful tool which enables us to write automated tests in functional descriptions. These descriptions are as easy to comprehend, as plain English. The purpose of this tool is to perfom BDD(Behavior-Driven-Development).</p>

<p>Consider this small snippet from my <a href="https://github.com/AnkurGel/statsample/blob/master/features/pacf.feature">pacf feature</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='cucumber'><span class='line'><span class="k">Feature:</span><span class="nf"> PACF</span>
</span><span class='line'>
</span><span class='line'><span class="nf">  As a statistician</span>
</span><span class='line'><span class="nf">  So that I can quickly evaluate partial autocorrelation of a series</span>
</span><span class='line'><span class="nf">  I want to evaluate pacf</span>
</span><span class='line'>
</span><span class='line'><span class="k">Background:</span><span class="nf"> a timeseries</span>
</span><span class='line'>
</span><span class='line'><span class="k">  Given </span><span class="nf">the following values in a timeseries:</span>
</span><span class='line'><span class="k">    |</span><span class="s"> timeseries</span><span class="k"> |</span><span class="nf"></span>
</span><span class='line'><span class="k">    |</span><span class="s"> 10  20  30  40  50  60  70  80  90  100</span><span class="k"> |</span><span class="nf"></span>
</span><span class='line'><span class="k">    |</span><span class="s"> 110 120 130 140 150 160 170 180 190 200</span><span class="k"> |</span>
</span><span class='line'>
</span><span class='line'><span class="k">Scenario:</span><span class="nf"> check pacf for 10 lags with unbiased</span>
</span><span class='line'><span class="k">  When </span><span class="nf">I provide </span><span class="s">10</span><span class="nf"> lags for pacf</span>
</span><span class='line'><span class="nf">  </span><span class="k">When </span><span class="nf">I provide yw yule walker as method</span>
</span><span class='line'><span class="nf">  </span><span class="k">Then </span><span class="nf">I should get Array as resultant output</span>
</span><span class='line'><span class="nf">  </span><span class="k">Then </span><span class="nf">I should get </span><span class="s">11</span><span class="nf"> values in resultant pacf</span>
</span><span class='line'>
</span><span class='line'><span class="k">Scenario:</span><span class="nf"> check pacf for 5 lags with mle</span>
</span><span class='line'><span class="k">  When </span><span class="nf">I provide </span><span class="s">5</span><span class="nf"> lags for pacf</span>
</span><span class='line'><span class="nf">  </span><span class="k">When </span><span class="nf">I provide mle yule walker as method</span>
</span><span class='line'><span class="nf">  </span><span class="k">Then </span><span class="nf">I should get Array as resultant output</span>
</span><span class='line'><span class="nf">  </span><span class="k">Then </span><span class="nf">I should get </span><span class="s">6</span><span class="nf"> values in resultant pacf</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes, these are tests! And they perform the operations as they say.</p>

<ul>
<li><p><code>Feature</code> denotes the feature this test will cover. It is followed by the description of the feature as:</p>

<ul>
<li><code>As a</code> statistician -> (use-case)</li>
<li><code>So that</code> I can quickly evaluate pacf of a seires -> (purpose)</li>
<li><code>I want</code> to evaluate pacf -> (expected result)</li>
</ul>
</li>
<li><p><code>Given</code> is analogous to <code>before</code> in RSpec. In context of <code>Background</code>, it denotes <code>before all</code>. That is, the forementioned time-series will be available in all scenarios furhter. This timeseries is resolved by <a href="http://rubygems.org/gems/gherkin">Gherkin</a> parser.
This is further resolved after parsing by following definition:</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Given</span> <span class="sr">/^the following values in a timeseries:$/</span> <span class="k">do</span> <span class="o">|</span><span class="n">series</span><span class="o">|</span>
</span><span class='line'>  <span class="n">arr</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'>  <span class="n">series</span><span class="o">.</span><span class="n">hashes</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">sequence</span><span class="o">|</span>
</span><span class='line'>    <span class="n">arr</span> <span class="o">+=</span> <span class="n">sequence</span><span class="o">[</span><span class="s1">&#39;timeseries&#39;</span><span class="o">].</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_i</span><span class="p">)</span><span class="o">.</span><span class="n">to_ts</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="vi">@timeseries</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">to_ts</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>Scenarios</code> cover the test cases with the combination of <code>When</code>, <code>And</code>, <code>Then</code> keywords.
They are regular English sentences and combine to form a gramatically sound process.
These sentences are then captured by regular-expressions written by programmer. For example;</li>
</ul>


<figure class='code'><figcaption><span>Scenario&#8217;s When clause</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cucumber'><span class='line'><span class="nf">  </span><span class="k">When </span><span class="nf">I provide </span><span class="s">10</span><span class="nf"> lags for pacf</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span>Converted DSL</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">When</span> <span class="sr">/^I provide (\d+) lags for p?acf$/</span> <span class="k">do</span> <span class="o">|</span><span class="n">lags</span><span class="o">|</span>
</span><span class='line'>  <span class="vi">@lags</span> <span class="o">=</span> <span class="n">lags</span><span class="o">.</span><span class="n">to_i</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Above will capture the lags and the strings like:</p>

<ul>
<li>When I provide 5 lags for pacf</li>
<li>When I provide 10 lags for acf</li>
</ul>


<p>Result: Compliant for both acf and pacf. :)</p>

<p>You can check my features and step definitions <a href="https://github.com/AnkurGel/statsample/tree/master/features">here</a>.</p>

<p>Cheers<br/>
Ankur Goel</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Statsample - Partial Autocorrelation]]></title>
    <link href="http://AnkurGel.github.io/blog/2013/07/06/statsample-partial-autocorrelation/"/>
    <updated>2013-07-06T14:00:00+05:30</updated>
    <id>http://AnkurGel.github.io/blog/2013/07/06/statsample-partial-autocorrelation</id>
    <content type="html"><![CDATA[<p>The <strong>partial autocorrelation</strong>(pacf) of an ARMA process is the function defined by the equation: <br/>
<code>f(0) = 1</code>, <code>f(x) = g(x)(x)</code> correlation of series with itself. for <code>x &gt;= 1</code></p>

<p>The first component of every pacf series is 1.</p>

<p>I implemented pacf with yule-walker equations of unbiased and mle outcomes.  Yule-walker equations are the set of equations represented by:  <br/>
<img src="https://upload.wikimedia.org/math/0/b/6/0b6c74023353b9ca598f842c07c3c286.png" alt="Courtesy: Wikipedia" /></p>

<p>Yule-walker uses the <a href="http://en.wikipedia.org/wiki/Toeplitz_matrix">Toeplitz matrix</a>(gives same output when stored in either row-major or column-major form) inverse with the outcomes to generate the intermediate vector results.</p>

<p>Here, we can generate pacf by making use of either <code>unbiased</code> and <code>mle</code> method with yule-walker function. For <code>unbiased</code>, the denominator is <code>(n-k)</code> whereas for <code>mle</code>, it is <code>n</code> (n is the size of time-series). To achieve that, I made use of fantastic Ruby <code>lambdas</code> to make a closure over the variable <code>k</code> as:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="nb">method</span><span class="o">.</span><span class="n">downcase</span><span class="o">.</span><span class="n">eql?</span> <span class="s1">&#39;yw&#39;</span>
</span><span class='line'>  <span class="c1">#unbiased =&gt; denominator = (n - k)</span>
</span><span class='line'>  <span class="n">denom</span> <span class="o">=-&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="p">}</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="c1">#mle</span>
</span><span class='line'>  <span class="c1">#denominator =&gt; (n)</span>
</span><span class='line'>  <span class="n">denom</span> <span class="o">=-&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="n">n</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Below might have been a viable shortcut, but I used former for maintaining descriptive comments and simplicity in code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">denom</span> <span class="o">=-&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="nb">method</span><span class="o">.</span><span class="n">downcase</span><span class="o">.</span><span class="n">eql?</span><span class="p">(</span><span class="s1">&#39;yw&#39;</span><span class="p">)</span> <span class="p">?</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="p">:</span> <span class="n">n</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://www-stat.wharton.upenn.edu/~steele/Courses/956/ResourceDetails/YWSourceFiles/YW-Eshel.pdf">Here is the useful description</a> and theoretical implementation of yule-walker by <em>University of Pennsylvania</em>.</p>

<p>Henceforth, the overall yule-walker method looks like following:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">yule_walker</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">method</span><span class="o">=</span><span class="s1">&#39;yw&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="c1">#From the series, estimates AR(p)(autoregressive) parameter</span>
</span><span class='line'>  <span class="c1">#using Yule-Waler equation. See -</span>
</span><span class='line'>  <span class="c1">#http://en.wikipedia.org/wiki/Autoregressive_moving_average_model</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">#parameters:</span>
</span><span class='line'>  <span class="c1">#ts = series</span>
</span><span class='line'>  <span class="c1">#k = order, default = 1</span>
</span><span class='line'>  <span class="c1">#method = can be &#39;yw&#39; or &#39;mle&#39;. If &#39;yw&#39; then it is unbiased, denominator</span>
</span><span class='line'>  <span class="c1">#is (n - k)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">#returns:</span>
</span><span class='line'>  <span class="c1">#rho =&gt; autoregressive coefficients</span>
</span><span class='line'>  <span class="n">ts</span> <span class="o">=</span> <span class="n">series</span> <span class="c1">#timeseries</span>
</span><span class='line'>  <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span> <span class="o">-</span> <span class="n">ts</span><span class="o">.</span><span class="n">mean</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">size</span>
</span><span class='line'>  <span class="k">if</span> <span class="nb">method</span><span class="o">.</span><span class="n">downcase</span><span class="o">.</span><span class="n">eql?</span> <span class="s1">&#39;yw&#39;</span>
</span><span class='line'>    <span class="c1">#unbiased =&gt; denominator = (n - k)</span>
</span><span class='line'>    <span class="n">denom</span> <span class="o">=-&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="c1">#mle</span>
</span><span class='line'>    <span class="c1">#denominator =&gt; (n)</span>
</span><span class='line'>    <span class="n">denom</span> <span class="o">=-&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="n">n</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">r</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">r</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">}</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="ss">:+</span><span class="p">)</span><span class="o">.</span><span class="n">to_f</span> <span class="o">/</span> <span class="n">denom</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">to_f</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="n">l</span> <span class="k">in</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.k</span><span class="p">)</span>
</span><span class='line'>    <span class="n">r</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ts</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">-l</span><span class="o">].</span><span class="n">zip</span><span class="p">(</span><span class="n">ts</span><span class="o">[</span><span class="n">l</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">size</span><span class="o">]</span><span class="p">))</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
</span><span class='line'>      <span class="n">x</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="ss">:*</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="ss">:+</span><span class="p">)</span><span class="o">.</span><span class="n">to_f</span> <span class="o">/</span> <span class="n">denom</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">.</span><span class="n">to_f</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">r_R</span> <span class="o">=</span> <span class="n">toeplitz</span><span class="p">(</span><span class="n">r</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">-</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">mat</span> <span class="o">=</span> <span class="no">Matrix</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span><span class="n">r_R</span><span class="p">)</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
</span><span class='line'>  <span class="n">solve_matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">r</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.r</span><span class="o">.</span><span class="n">size</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>toeplitz</code> method generates the Toeplitz matrix, and <code>solve_matrix</code> solves the equation by using the inverse and matrix muliplication.</p>

<p><code>pacf</code> is available in <code>Statsample::TimeSeries</code> and can be called as:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">series</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">10</span> <span class="p">}</span><span class="o">.</span><span class="n">to_ts</span>
</span><span class='line'><span class="c1">#Usage: pacf(lags, method), method = &#39;yw&#39; =&gt; unbiased, &#39;mle&#39; =&gt; mle</span>
</span><span class='line'><span class="n">series</span><span class="o">.</span><span class="n">pacf</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;yw&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; results</span>
</span></code></pre></td></tr></table></div></figure>


<p>The entire implementation can be seen at : <a href="https://github.com/AnkurGel/statsample/blob/master/lib/statsample/timeseries.rb#L151">https://github.com/AnkurGel/statsample/blob/master/lib/statsample/timeseries.rb#L151</a> with it&#8217;s tests at : <a href="https://github.com/AnkurGel/statsample/blob/master/test/test_pacf.rb">https://github.com/AnkurGel/statsample/blob/master/test/test_pacf.rb</a></p>

<p>Cheers,
/-Ankur Goel</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Statsample - Wald test]]></title>
    <link href="http://AnkurGel.github.io/blog/2013/07/06/statsample-wald-test/"/>
    <updated>2013-07-06T13:59:00+05:30</updated>
    <id>http://AnkurGel.github.io/blog/2013/07/06/statsample-wald-test</id>
    <content type="html"><![CDATA[<p>Hi everyone, <br/>
After completing and verifying the integrity of all tests and Ruby versions, I and Claudio started with implementation of Wald Test. He explained it pretty well and was very patient. :)</p>

<p>Wald test is used to test if a series of n acf or pacf indeces are equal to 0.<br/>
For <code>acf</code>, the distribution for a white noise sationary process are approximately independent and identically distributed normal random variables with mean 0 and variance n<sup><sup></sup>-1.</sup></p>

<p>What that means is, if terms in an <code>acf</code> of a timeseries with k lags are squared and added (sum-of-squares), then that statistic is chi-square distributed over degree of freedom, directly dependent on the k number of lags.</p>

<p>I will demonstrate this with example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#Create time series</span>
</span><span class='line'>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;statsample&#39;</span>
</span><span class='line'><span class="kp">include</span> <span class="ss">Statsample</span><span class="p">:</span><span class="ss">:TimeSeries</span>
</span><span class='line'><span class="n">series</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">30</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="p">}</span><span class="o">.</span><span class="n">to_time_series</span>
</span><span class='line'>
</span><span class='line'><span class="c1">#find and stores it acf with specific lags</span>
</span><span class='line'><span class="n">k</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class='line'><span class="n">series_acf</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">acf</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">#find sum of squares for series_acf using powerful Ruby map and inject.</span>
</span><span class='line'><span class="n">sum_of_sq</span> <span class="o">=</span> <span class="n">series_acf</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">}</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="ss">:+</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>So far, we have managed to find the sum of squares of a acf-series with k = 10 = number of lags. <br/>
Now, we will check whether or not it is less than quantile 0.95 of a <code>chi-square</code> with <code>k</code> degree of freedom.</p>

<p>For that, include <code>Distribution</code> as:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#continuing from last snippet</span>
</span><span class='line'>
</span><span class='line'><span class="kp">include</span> <span class="no">Distribution</span>
</span><span class='line'><span class="n">cdf</span> <span class="o">=</span> <span class="no">ChiSquare</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">sum_of_sq</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">cdf</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">.</span><span class="mo">05</span>
</span><span class='line'><span class="c1">#=&gt; True</span>
</span></code></pre></td></tr></table></div></figure>


<p>This verifies the Wald test.</p>

<p>The tests can be found on Github repository at: <a href="https://github.com/AnkurGel/statsample/blob/master/test/test_wald2.rb">https://github.com/AnkurGel/statsample/blob/master/test/test_wald2.rb</a></p>

<p>Cheers, <br/>
Ankur Goel</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[StatSample - Correcting tests and configuration]]></title>
    <link href="http://AnkurGel.github.io/blog/2013/06/24/statsample-correcting-tests-and-configuration/"/>
    <updated>2013-06-24T14:39:00+05:30</updated>
    <id>http://AnkurGel.github.io/blog/2013/06/24/statsample-correcting-tests-and-configuration</id>
    <content type="html"><![CDATA[<p>In previous blog, I mentioned about the <code>Shoulda</code> issues with MiniTest while running the tests. The error which I encounter looks something like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>  <span class="nb">test </span>git:<span class="o">(</span>master<span class="o">)</span>  ruby test_anovaoneway.rb
</span><span class='line'>test_anovaoneway.rb:3:in <span class="sb">`</span>&lt;class:StatsampleAnovaOneWayTestCase&gt;<span class="s1">&#39;: undefined method `context&#39;</span> <span class="k">for </span>StatsampleAnovaOneWayTestCase:Class <span class="o">(</span>NoMethodError<span class="o">)</span>
</span><span class='line'>  from test_anovaoneway.rb:2:in <span class="sb">`</span>&lt;main&gt;<span class="s1">&#39;</span>
</span><span class='line'><span class="s1">  test git:(master)  ruby test_regression.rb </span>
</span><span class='line'><span class="s1">test_regression.rb:4:in `&lt;class:StatsampleRegressionTestCase&gt;&#39;</span>: undefined method <span class="sb">`</span>context<span class="s1">&#39; for StatsampleRegressionTestCase:Class (NoMethodError)</span>
</span><span class='line'><span class="s1">  from test_regression.rb:3:in `&lt;main&gt;&#39;</span>
</span><span class='line'>  <span class="nb">test </span>git:<span class="o">(</span>master<span class="o">)</span> 
</span></code></pre></td></tr></table></div></figure>


<p>While adding tests for regression, I worked around it by converting them in pure <code>MiniTest</code> references. I just <a href="https://github.com/AnkurGel/statsample/commit/734f3be565090b7168b286fec90a48c07089fdba">committed tests</a> for F following similar analogy. I am currently trying to make Shoulda work which could probably save some work involved in conversion.</p>

<p>For setting up StatSample to make it work on multiple Ruby versions, I have configured <a href="https://rvm.io/"><code>rvm</code></a>(tool to manage multiple ruby environments with their own gemsets) with Ruby <code>1.9.2-p320</code>, <code>1.9.3</code>. I also <a href="https://github.com/AnkurGel/statsample/commit/acc618ef5fd26577e65484024d4086ede4f226d6">committed</a> a clean <code>gemspec</code> for StatSample. I hope to make StatSample compatible for both first, and then fix it for <code>Ruby-1.8.x</code>, as this is usually the workflow which <em>just works</em>.</p>

<p>As always, project can be forked from <a href="http://github.com/AnkurGel/statsample">http://github.com/AnkurGel/statsample</a>.  <br/>
You can now build it by:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>gem build statsample.gemspec
</span><span class='line'>gem install statsample-1.1.0.2013.gem
</span></code></pre></td></tr></table></div></figure>


<p>Do let me know of any trouble you encounter at ankurgel at gmail dot com.</p>

<p>Cheers! <br/>
-Ankur Goel</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[StatSample | Code Begins]]></title>
    <link href="http://AnkurGel.github.io/blog/2013/06/22/statsample-code-begins/"/>
    <updated>2013-06-22T09:51:00+05:30</updated>
    <id>http://AnkurGel.github.io/blog/2013/06/22/statsample-code-begins</id>
    <content type="html"><![CDATA[<p>Hi everyone!</p>

<p>This summer, I am working with Ruby Science Foundation for StatSample project. As you must have read in <a href="http://ankurgoel.com/blog/archives/">previous blog posts</a>; StatSample is a powerful statistical library in <strong>Ruby</strong>. Unfortunately, development of this great utility has been on hold from last 2 years. My project aims to revamp StatSample and primarily to enhance functionality for TimeSeries and Generalized Linear Models.</p>

<p>You can read more about my proposal, <a href="http://www.google-melange.com/gsoc/project/google/gsoc2013/ankurgel/63001">here</a>.</p>

<p>During the community bonding period, I initially studied on few topics which my project is concerned about - primarily, estimation methods like <a href="https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average">ARIMA</a>. I saw it&#8217;s implementation in alternative statistical applications like R and StatsModels. <a href="http://statsmodels.sourceforge.net/devel/generated/statsmodels.tsa.arima_model.ARIMA.html#statsmodels.tsa.arima_model.ARIMA">StatsModels</a> uses Kalman filter for maximum likelihood and provides other estimations such as <a href="http://en.wikipedia.org/wiki/Likelihood_function#Log-likelihood">log-likelihood</a> and conditional-sum-of-squares etc. The basic interface for ARIMA in StatsModels is as follows:</p>

<figure class='code'><figcaption><span>ARIMA class in StatsModels</span><a href='https://github.com/statsmodels/statsmodels/blob/master/statsmodels/tsa/arima_model.py'>Source code of class</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">ARIMA</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">dates</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</span><span class='line'><span class="c">#series =&gt; list of timeseries values</span>
</span><span class='line'><span class="c">#order  =&gt; ARIMA order(p=autoregressive, d=differenced, q=moving average)</span>
</span><span class='line'><span class="c">#dates  =&gt; [optional] timeline</span>
</span></code></pre></td></tr></table></div></figure>


<p>The returned ARIMA object can be called with :</p>

<ul>
<li><a href="https://github.com/statsmodels/statsmodels/blob/master/statsmodels/tsa/arima_model.py#L924"><code>fit(...)</code></a> for maximum likelihood with primarily three methods - maximum-likelihood, conditional-sum-of-squares, css-then-mle.</li>
<li><a href="https://github.com/statsmodels/statsmodels/blob/master/statsmodels/tsa/arima_model.py#L1004"><code>predict(...)</code></a>, it is a recursive function which gives back list of predictedvalues for supplied varying series.</li>
<li><a href="https://github.com/statsmodels/statsmodels/blob/master/statsmodels/tsa/arima_model.py#L667"><code>loglike_css(...)</code></a> - stands for conditional-sum-of-squares, returns aggregated css value.</li>
</ul>


<p>The R Project too has substantial work in ARIMA. I talked about it on <a href="https://groups.google.com/forum/?fromgroups=#!topic/sciruby-dev/Qc62IG7RMi0">mailing list</a>. Thanks to <a href="https://groups.google.com/d/msg/sciruby-dev/Qc62IG7RMi0/J9AYMi7-V2YJ">John&#8217;s concerns</a>, researching more in StatsModels was good idea than in R. In StatSample, we <em>should</em> work on ARIMA module as idiomatically they have done in <a href="https://github.com/statsmodels/statsmodels/blob/master/statsmodels/tsa/arima_model.py">StatsModels</a>. <br/>
Beside this, I honestly didn&#8217;t get much time to devote to project during this period because of my then ongoing semester examinations, which I initially brought into notice to my mentors.</p>

<p>Currently, I am working on repairing and brining uniformity in tests. StatSample&#8217;s tests are written in MiniTest <strong>primarily</strong>, and somewhere making use of <code>shoulda</code> DSL. Tests using the latter, are breaking on my system with:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>  <span class="nb">test </span>git:<span class="o">(</span>master<span class="o">)</span>  ruby test_anovaoneway.rb
</span><span class='line'>test_anovaoneway.rb:3:in <span class="sb">`</span>&lt;class:StatsampleAnovaOneWayTestCase&gt;<span class="s1">&#39;: undefined method `context&#39;</span> <span class="k">for </span>StatsampleAnovaOneWayTestCase:Class <span class="o">(</span>NoMethodError<span class="o">)</span>
</span><span class='line'>  from test_anovaoneway.rb:2:in <span class="sb">`</span>&lt;main&gt;<span class="s1">&#39;</span>
</span><span class='line'><span class="s1">  test git:(master)  ruby test_regression.rb </span>
</span><span class='line'><span class="s1">test_regression.rb:4:in `&lt;class:StatsampleRegressionTestCase&gt;&#39;</span>: undefined method <span class="sb">`</span>context<span class="s1">&#39; for StatsampleRegressionTestCase:Class (NoMethodError)</span>
</span><span class='line'><span class="s1">  from test_regression.rb:3:in `&lt;main&gt;&#39;</span>
</span><span class='line'>  <span class="nb">test </span>git:<span class="o">(</span>master<span class="o">)</span> 
</span></code></pre></td></tr></table></div></figure>


<p>To aid this, I am correcting and testing specs as : <a href="https://github.com/AnkurGel/statsample/commit/47ff467f9866798e0917cd75ccb21ad046c3b0d3">commit</a>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>  statsample git:<span class="o">(</span>master<span class="o">)</span>  ruby <span class="nb">test</span>/test_regression2.rb
</span><span class='line'>Run options: --seed 40873
</span><span class='line'>
</span><span class='line'><span class="c"># Running tests:</span>
</span><span class='line'>
</span><span class='line'>..S......
</span><span class='line'>
</span><span class='line'>Finished tests in 0.176938s, 50.8652 tests/s, 740.3708 assertions/s.
</span><span class='line'>
</span><span class='line'>9 tests, 131 assertions, 0 failures, 0 errors, 1 skips
</span><span class='line'>  statsample git:<span class="o">(</span>master<span class="o">)</span> 
</span></code></pre></td></tr></table></div></figure>


<p>Hopefully, setting up the codebase in good position will work great as I dwell in coding further with TimeSeries.</p>

<p>Github: <a href="http://github.com/AnkurGel/statsample">http://github.com/AnkurGel/statsample</a></p>

<p>Cheers! <br/>
-Ankur Goel</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Examples with Statsample]]></title>
    <link href="http://AnkurGel.github.io/blog/2013/04/24/examples-with-statsample/"/>
    <updated>2013-04-24T16:51:00+05:30</updated>
    <id>http://AnkurGel.github.io/blog/2013/04/24/examples-with-statsample</id>
    <content type="html"><![CDATA[<h2><u>TimeSeries</u></h2>

<p>Statsample has a module for Time Series as <code>Statsample::TimeSeries</code>. This module has a class named <code>TimeSeries</code> which enables users to perform operations on sequence of data points, indexed by time and ordered from earliest to latest. Example: Stock data.
Suppose, we have a time series as:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">timeseries</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nb">rand</span> <span class="mi">100</span> <span class="p">}</span><span class="o">.</span><span class="n">to_ts</span>
</span><span class='line'><span class="c1">#=&gt; Time Series(type:scale, n:10)[62,91,92,71,86,99,80,64,15,94]</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is the returned TimeSeries object which is now capable of performing several interesting operations such as:</p>

<h3>Lag</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">timeseries</span><span class="o">.</span><span class="n">lag</span>
</span><span class='line'><span class="c1">#=&gt; Vector(type:scale, n:10)[nil,62,91,92,71,86,99,80,64,15]</span>
</span><span class='line'><span class="n">timeseries</span><span class="o">.</span><span class="n">lag</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="c1">#Lag of series by three units, will place nil in first three positions.</span>
</span><span class='line'><span class="c1">#=&gt; Vector(type:scale, n:10)[nil,nil,nil,62,91,92,71,86,99,80]</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Auto-Correlation</h3>

<p>This is frequently used statistical operation. In Digital signal processing, autocorrelation of series is the cross-correlation of signal with itself, but without the normalization. Though, in statistics, normalization exists.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">timeseries</span><span class="o">.</span><span class="n">acf</span>
</span><span class='line'><span class="c1">#=&gt; Returns the auto-correlation of series.</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Diff</h3>

<p><code>diff</code> performs the first difference of the series. That is difference of series with itself and it&#8217;s first lag.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">timeseries</span><span class="o">.</span><span class="n">diff</span>
</span><span class='line'><span class="c1">#=&gt; Time Series(type:scale, n:10)[nil,29,1,-21,15,13,-19,-16,-49,79]</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Exponential moving average</h3>

<p>Moving average is a finite impulse response filter which creates a series of averages of subsets of full-data to analyze the given set of data points. <br/>
<a href="http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average">EMA</a> is similar to moving average, but more weight is given to latest data. <br/>
<img src="http://user42.tuxfamily.org/chart/manual/chart-ema-weights.png" alt="image_ema" /> <br/>
In StatSample, EMA can be accessed from <code>TimeSeries</code> by calling <code>ema</code> on a timeseries. Example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">t_series</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nb">rand</span> <span class="p">}</span><span class="o">.</span><span class="n">to_timeseries</span>
</span><span class='line'><span class="n">t_series</span><span class="o">.</span><span class="n">ema</span>
</span><span class='line'><span class="n">t_series</span><span class="o">.</span><span class="n">ema</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; uses 15 observations and sets Welles wilder coefficient to true.</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>acf</code> takes optional parameters - n(default: 10) that accounts on how many observations to consider and Welles Wilder coefficent(default: zero) which uses smoothing value of <code>2/(n + 1)</code> on false and <code>1/n</code> on true.</p>

<p><code>TimeSeries</code> module, as can be seen, can become highly sophisticated on inclusion of other methods such as <a href="http://en.wikipedia.org/wiki/Autoregressive%E2%80%93moving-average_model">ARMA Estimation</a> etc.</p>

<h2><u>Simple Random Sampling</u></h2>

<p>SRS is an unbiased technique to choose subset of individuals (sample) from a larger set (called, population). Selection of each individual in that sample is entirely random and has equal probability as other individuals. Various techniques for SRS is <a href="http://stattrek.com/Lesson6/SRS.aspx">given here</a>. <br/>
<code>SRS</code> is a module in StatSample which comprises of various sections for Proportion estimation, confidence intervals, standard deviation, mean estimation etc. <br/>
I covered various tests of SRS methods <a href="https://github.com/AnkurGel/statsample/commit/80f7a73be015d2ac7f531fb2125363a6617f0fab">here</a>, as I explored and understood them. I am currently still writing few more tests for this and other modules in StatSample.</p>

<p>I will update the post as soon as I write them. If anyone wishes me to write about the detailed functionality of this module too, please comment. I will be delighted to do that.</p>

<p>Cheers, <br/>
-Ankur Goel</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[StatSample]]></title>
    <link href="http://AnkurGel.github.io/blog/2013/04/24/statsample/"/>
    <updated>2013-04-24T13:51:00+05:30</updated>
    <id>http://AnkurGel.github.io/blog/2013/04/24/statsample</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/sciruby/statsample">Statsample</a> is a statistical library for Ruby and is actively developed by folks at SciRuby. Currently, Statsample is supported with Ruby 1.8.7, 1.9.1, 1.9.2 and ruby-head.</p>

<p>Statsample is currently makes use of Ruby/GSL which uses NArray for vector and matrix operations. It conflicts with the SciRuby&#8217;s NMatrix which also uses the same class names - NMatrix and NVector. Thus, this conflict makes Statsample unusable for system which already has NMatrix. To aid this, SciRuby developed a fork of <a href="http://github.com/SciRuby/rb-gsl">rb-gsl</a> which makes use of NMatrix instead of NArray. I went through it&#8217;s code structure and found it to be great. Devs did a great job in removing many references of NArray and made use of NMatrix in lieu of that.</p>

<p>Statsample is <a href="https://github.com/SciRuby/sciruby/wiki/Google-Summer-of-Code-2013-Ideas#statsample">purposed idea</a> for <a href="http://google-melange.com">Google Summer of Code 2013</a> program. And, I am excited about making Statsample more flexible by covering various aspects:</p>

<ul>
<li>Make Statsample compatible for Ruby 1.9.3+</li>
<li>Enable Statsample to require <a href="http://github.com/SciRuby/rb-gsl">rb-gsl fork</a> instead.</li>
<li>Add more tests to the code and cover the documentation using existing style of NMatrix.</li>
<li>Implement modules for Generalized Linear Models(GLM) and Time Series Analysis.</li>
</ul>


<p>I have been playing around with existing codebase by writing few examples and test cases from few days and had <a href="https://groups.google.com/forum/?fromgroups=#!topic/sciruby-dev/SqXJLJnd6Xs">discussion</a> about this with fellow folks at SciRuby (John Woods, Claudio Bustos and Carlos Agarie). I&#8217;m very grateful for their response and persuasion. The discussion with them helped me to clarify many aspects which were a little obscure earlier. :)</p>

<p>Just before writing down this blog-entry, I was trying out <strong>TimeSeries</strong> class and it&#8217;s methods. I simply loved it - the ease with which I was able to compute the operations, I learnt back in Digital Signal processing such as lagging of series, autocorrelation, exponential moving average etc is <em>mindblowing</em>. It currently supports many basic operations, which after the successful execution of this project can definitely be expanded.</p>

<p>I will be delighted to work on Statsample in this summer, if given an opportunity.</p>

<p>Cheers! <br/>
- Ankur Goel</p>

<p><em>PS</em>: I will try to blog with example codes in next posts.</p>
]]></content>
  </entry>
  
</feed>
